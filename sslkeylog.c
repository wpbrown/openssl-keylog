/*
 * Copyright (C) 2014 Peter Wu <peter@lekensteyn.nl>
 *               2021 wpbrown
 * Licensed under the terms of GPLv3 (or any later version) at your choice.
 */

#define _GNU_SOURCE /* for RTLD_NEXT */
#include <dlfcn.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef OPENSSL_SONAME
#define OPENSSL_SONAME "libssl.so.1.1"
#endif

#define MAX_PATH 512
#define FIRSTLINE     "# SSL key logfile generated by sslkeylog.c\n"
#define FIRSTLINE_LEN (sizeof(FIRSTLINE) - 1)

typedef struct ssl_st SSL;
typedef struct ssl_ctx_st SSL_CTX;

static int keylog_file_fd = -1;

void *real_dlsym(void *handle, const char *name);

static void init_keylog_file(void)
{
    char filename_pid[MAX_PATH];

    if (keylog_file_fd >= 0)
        return;

    const char *filename = getenv("HOOKED_SSLKEYLOGFILE");
    if (!filename)
        filename = getenv("SSLKEYLOGFILE");

    if (!filename) 
        return;

    size_t filename_len = strlen(filename);
    if (filename_len < MAX_PATH - 12) {
        strcpy(filename_pid, filename);
        snprintf(&filename_pid[filename_len], MAX_PATH - filename_len, ".%d", (int)getpid());
        keylog_file_fd = open(filename_pid, O_WRONLY | O_APPEND | O_CREAT, 0644);
        if (keylog_file_fd >= 0 && lseek(keylog_file_fd, 0, SEEK_END) == 0) {
            /* file is opened successfully and there is no data (pos == 0) */
            write(keylog_file_fd, FIRSTLINE, FIRSTLINE_LEN);
        }
    }
}

static inline void *lookup_symbol(const char *sym)
{
    void *func = real_dlsym(RTLD_NEXT, sym);

    if (!func) {
        void *handle = dlopen(OPENSSL_SONAME, RTLD_LAZY);
        if (!handle) {
            fprintf(stderr, "Lookup error for %s: %s\n", sym, dlerror());
            abort();
        }
        func = real_dlsym(handle, sym);
        if (!func) {
            fprintf(stderr, "Cannot lookup %s\n", sym);
            abort();
        }
        dlclose(handle);
    }

    return func;
}

static void keylog_callback(const SSL *ssl, const char *line)
{
    init_keylog_file();
    if (keylog_file_fd >= 0) {
        fprintf(stderr, "[SSLKEYLOG] CB\n");
        write(keylog_file_fd, line, strlen(line));
        write(keylog_file_fd, "\n", 1);
    }
}

SSL *SSL_new(SSL_CTX *ctx)
{
    static SSL *(*func)();
    static void (*set_keylog_cb)();
    if (!func) {
        fprintf(stderr, "[SSLKEYLOG] INIT\n");
        func = lookup_symbol(__func__);
        set_keylog_cb = lookup_symbol("SSL_CTX_set_keylog_callback");
    }
    if (set_keylog_cb) {
        fprintf(stderr, "[SSLKEYLOG] ENABLING\n");
        /* Override any previous key log callback. */
        set_keylog_cb(ctx, keylog_callback);
    }
    return func(ctx);
}

extern void *dlsym(void *handle, const char *name)
{
    if (!strcmp(name,"dlsym")) 
        // fprintf(stderr, "[SSLKEYLOG] DLSYM itself\n");
        return dlsym;

    if (!strcmp(name,"SSL_new")) {
        fprintf(stderr, "[SSLKEYLOG] DLSYM SSL_NEW\n");
        return SSL_new;
    }
    //fprintf(stderr, "[SSLKEYLOG] REALDLSYM %s\n", name);
    return real_dlsym(handle,name);
}

#if __GLIBC__ > 2 || (__GLIBC == 2 &&  __GLIBC_MINOR__ >= 34)
    #define GLIBC_API_VERSION "GLIBC_2.34"
#else 
    #define GLIBC_API_VERSION "GLIBC_2.2.5"
#endif        

void *real_dlsym(void *handle, const char *name)
{
    static void * (*real_dlsym)(void *, const char *)=NULL;
    if (real_dlsym == NULL)
        real_dlsym=dlvsym(RTLD_NEXT, "dlsym", GLIBC_API_VERSION);

    return real_dlsym(handle,name);
}